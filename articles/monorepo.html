<!DOCTYPE html><html lang="zh-CN" class="scroll-smooth dark"><head><meta charSet="utf-8"/><meta charSet="utf-8"/><link rel="stylesheet" href="/_next/static/css/26351ac1a6eca06c.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/7f6bd37aab40623f.css" data-precedence="next"/><title>HAN Blog</title><meta name="description" content="Created by HAN"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="\favicon.ico" type="image/x-icon" sizes="any"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body><div class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="h-screen flex flex-col justify-between"><header class="flex items-center justify-around py-10"><div><a href="/"><div class="flex items-center justify-between"><div class="hidden h-6 text-2xl font-semibold sm:block"><a>HAN个人博客</a></div></div></a></div><div class="flex items-center text-base leading-5"><div class="hidden sm:block"><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/">主页</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/articles">文章</a><a class="p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4" href="/about">关于</a></div></div><div></div></header><main class="mb-auto"><main><div class="flex justify-center"><div class="prose dark:prose-invert mt-10"><h1>使用 Next.js 搭建 Monorepo 组件库文档</h1><div class="items-center"><a href="articles">返回文档列表</a></div><div><blockquote>
<p>文章为稀土掘金技术社区首发签约文章，14 天内禁止转载，14 天后未获授权禁止转载，侵权必究！</p>
</blockquote>
<h2>阅读本文你将：</h2>
<ul>
<li>使用 pnpm 搭建一个 Monorepo 组件库</li>
<li>使用 Next.js 开发一个组件库文档</li>
<li>changesets 来管理包的 version 和生成 changelog</li>
<li>使用 vercel 部署在线文档</li>
</ul>
<p>代码仓库：https://github.com/maqi1520/nextjs-components-docs</p>
<h2>前言</h2>
<p>组件化开发是前端的基石，正因为组件化，前端得以百花齐放，百家争鸣。我们每天在项目中都写着各种各样的组件，如果在面试的时候，跟面试官说，你每天的工作是开发组件，那么显然这没有什么优势，如果你说，你开发了一个组件库，并且有一个在线文档可以直接预览，这可能会是你的一个加分项。今天我们就来聊聊组件库的开发，主要是组件库的搭建和文档建设，至于组件数量，那是时间问题，以及你是否有时间维护好这个组件库的问题。</p>
<h2>基础组件和业务组件</h2>
<p>首先组件库分为基础组件和业务组件，所谓基础组件就是 UI 组件，类似 Ant design，它是单包架构，所有的组件都是在一个包中，一旦其中一个组件有改动，就需要发整包。另外一种是业务组件，组件中包含了一些业务逻辑，它在企业内部是很有必要的。比如飞书文档，包含在线文档，在线 PPT、视频会议等，这些都是独立的产品，单独迭代开发，单独发布，却有一些共同的逻辑，比如没有登录的时候都需要调用一个”登录弹窗“，或者说在项目协同的时候，都需要邀请人员加入，那么需要一个“人员选择组件”， 这就是业务组件。业务组件不同于基础组件，单独安装，依赖发包，而并不是全量发包。那么这些业务组件也需要一个文档，因此我们使用 Monorepo（单仓库管理），这样方便管理和维护。</p>
<h2>为什么选用 Next.js 来搭建组件库文档？</h2>
<p>组件文档有个特别重要的功能就是“写 markdown 文档，可以看到代码以及运行效果”，这方面有很多优秀的开源库，比如 Ant design 使用的是 <a href="https://github.com/benjycui/bisheng" title="bisheng">bisheng</a>， react use 使用的是 <a href="https://github.com/storybookjs/storybook" title="storybook">storybook</a>， 还有一些优秀的库，比如：<a href="https://github.com/umijs/dumi" title="dumi">dumi</a>，<a href="https://github.com/doczjs/docz" title="docz">Docz</a> 等。 本地跑过 Ant design 的同学都知道， Ant design 的启动速度非常慢，因为底层使用的 webpack，要启动开发服务器，必须将所有组件都进行编译，这会对开发者造成一些困扰，因为如果是业务组件的话，开发者只关注单个组件，而不是全部组件。而使用 Next.jz 就有 2 个非常大的优势：</p>
<ul>
<li>使用 swc 编译，Next.js 中实现了快 3 倍的快速刷新和快 5 倍的构建速度；</li>
<li>按需编译，在开发环境下，只有访问的页面才会进行编译</li>
</ul>
<p>那么接下来的问题就是：要在 Next.js 中实现 “写 Markdown Example 可预览”的功能，若要自己实现这个功能，确实是一件麻烦的事情。我们换一个思维，组件展示，也就是在 markdown 中运行 react 组件，这不就是 <a href="https://github.com/mdx-js/mdx" title="mdx">mdx</a> 的功能吗？ 而在 Next.js 中可以很方便地集成 MDX。</p>
<h2>效果演示  </h2>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dc62765c903439ea4654ef5f1dcd646~tplv-k3u1fbpfcp-zoom-1.image" alt="实现效果"></p>
<p>目前这是一个简易版，只为展示 Next.js 搭建文档</p>
<h2>项目初始化</h2>
<p>首先我们创建一个 next typescript 作为我们项目的主目录，用于组件库的文档开发</p>
<pre><code>npx create-next-app@latest --ts
</code></pre>
<p>要想启动 pnpm 的 workspace 功能，需要工程根目录下存在 <code>pnpm-workspace.yaml</code> 配置文件，并且在 <code>pnpm-workspace.yaml</code> 中指定工作空间的目录。比如这里我们所有的子包都是放在 packages 目录下</p>
<pre><code>packages:
  - 'packages/*'
</code></pre>
<p>接下来，我们在 packages 文件夹下创建三个子项目，分别是：user-select、login 和 utils， 对应用户选择，登录 和工具类。</p>
<pre><code>├── packages
│   ├── user-select
│   ├── login
│   ├── utils
</code></pre>
<p>user-select 和 login 依赖 utils，我们可以将一些公用方法放到 utils 中。</p>
<p>给每个 package 下面创建 <code>package.json</code> 文件，包名称通常是”@命名空间+包名@“的方式，比如@vite/xx 或@babel/xx，在本例中，这里我们都以<code>@mastack</code>开头</p>
<pre><code>{
  "name": "@mastack/login",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
</code></pre>
<p>给每个 package 安装 typescript</p>
<pre><code>pnpm add typescript -r  -D
</code></pre>
<p>给每个 package 创建 tsconfig.json 文件</p>
<pre><code>{
  "include": ["src/**/*"],
  "compilerOptions": {
    "jsx": "react",
    "outDir": "dist",
    "target": "ES2020",
    "module": "esnext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "moduleResolution": "node",
    "declaration": true,
    "forceConsistentCasingInFileNames": true
  }
}
</code></pre>
<p>执行下面代码，往 login 组件中安装 utils;</p>
<pre><code>pnpm i @mastack/utils --filter @mastack/login
</code></pre>
<p>安装完成后，设置依赖版本的时候推荐用 <code>workspace:*</code>，就可以保持依赖的版本是工作空间里最新版本，不需要每次手动更新依赖版本。</p>
<p>pnpm 提供了 <code>-w</code>, <code>--workspace-root</code> 参数，可以将依赖包安装到工程的根目录下，作为所有 package 的公共依赖，这么我们安装 <code>antd</code></p>
<pre><code>pnpm install antd -w
</code></pre>
<h2>组件开发</h2>
<p>我们在 login 组件下，新建一个组件 <code>src/index.tsx</code></p>
<pre><code>import React, { useState } from 'react'
import { Button, Modal } from 'antd'

interface Props {
  className: string;
}

export default function Login({ className }: Props) {
  const [open, setopen] = useState(false)
  return (
    &#x3C;>
      &#x3C;Button onClick={() => setopen(true)} className={className}>
        登录
      &#x3C;/Button>
      &#x3C;Modal title="登录" open={open} onCancel={() => setopen(false)} onOk={() => setopen(false)}>
        &#x3C;p>登录弹窗&#x3C;/p>
      &#x3C;/Modal>
    &#x3C;/>
  )
}
</code></pre>
<p>先写一个最简单版本，组件代码并不是最重要的，后续可以再优化。</p>
<p>在 package.json 中添加构建命令</p>
<pre><code>"scripts": {
    "build": "tsc"
  }
</code></pre>
<p>然后在组件目录下执行 <code>yarn build</code> 。此时组件以及可以打包成功！</p>
<h2>Next.js 支持 MDX</h2>
<p>接下来要让文档支持 MDX，在根目录下执行以下命令，安装 mdx 和 loader 相关包</p>
<pre><code>pnpm add @next/mdx @mdx-js/loader @mdx-js/react -w
</code></pre>
<p>修改 <code>next.config.js</code> 为以下代码</p>
<pre><code>const withMDX = require('@next/mdx')({
  extension: /\.mdx?$/,
})

module.exports = withMDX({
  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],
  reactStrictMode: true,
  swcMinify: true,
})
</code></pre>
<p>这样就可以在 Next 中支持 MDX 了。</p>
<p>我们在 <code>src/pages</code> 目录下，新建一个 <code>docs/index.mdx</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47e827c0dfbb4623875c4b9e16206471~tplv-k3u1fbpfcp-zoom-1.image" alt="markdown 信息"></p>
<p>先写一个简单的 markdown 文件测试下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30f3a4c0bcad4fe782d1fe0b5594d873~tplv-k3u1fbpfcp-zoom-1.image" alt="markdown 渲染"></p>
<p>这样 Next.js 就支持 mdx 文档了。</p>
<h2>Next 动态加载 md 文件</h2>
<p>接下来，我们要实现动态加载 packages 中的文件 md 文件。新建一个 <code>pages/docs/[...slug].tsx</code> 文件。</p>
<pre><code>export async function getStaticPaths(context: GetStaticPathsContext) {
  return {
    paths: [{ params: { slug: ['login'] } }, { params: { slug: ['user-selecter'] } }],
    fallback: false, // SSG 模式
  }
}

export async function getStaticProps({ params }: GetStaticPropsContext&#x3C;{ slug: string[] }>) {
  const slug = params?.slug.join('/')

  return {
    props: {
      slug,
    }, // 传递给组件的props
  }
}
</code></pre>
<p>我们使用的是 SSG 模式。上面代码中 <code>getStaticPaths</code> 我先写了 2 条数据，因为我们目前只有 2 个组件，它会在构建的时候会生成静态页面。 <code>getStaticProps</code>函数可以获取 URL 上的参数，我们将 slug 参数传递给组件，然后在 Page 函数中，我们使用 <code>next/dynamic</code> 动态加载 packages 中的 mdx 文件</p>
<pre><code>import React from 'react'
import { GetStaticPathsContext, InferGetServerSidePropsType, GetStaticPropsContext } from 'next'
import dynamic from 'next/dynamic'

type Props = InferGetServerSidePropsType&#x3C;typeof getStaticProps>

export default function Page({ slug }: Props) {
  const Content = dynamic(() => import(`../packages/${slug}/docs/index.mdx`), {
    ssr: false,
  })

  return (
    &#x3C;div>
      &#x3C;Content />
    &#x3C;/div>
  )
}
</code></pre>
<p>此时我们访问 <code>http://localhost:3000/docs/login</code> 查看效果</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a084dc67f5f84f72b22af0c99e451d78~tplv-k3u1fbpfcp-zoom-1.image" alt="Next.js 编译报错"></p>
<p>在页面上会提示，无法找到<code>@mastack/login</code> 这个包，我们需要在项目的根目录下的 <code>tsconfig.json</code> 中加入别名</p>
<pre><code>{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"],
      "@mastack/login": ["packages/login/src"],
      "@mastack/user-select": ["packages/user-select/src"]
    }
  }
}
</code></pre>
<p>保存后，页面会自动刷新，我们就可以在页面上看到如下效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e97447d2968a46c89d1f63f1c9883d83~tplv-k3u1fbpfcp-zoom-1.image" alt="Next.js  动态加载 mdx"></p>
<p>至此文档与 packages 目录下的 mdx 已经打通。修改 <code>packages/login/docs/index.mdx</code> 中的文档，页面会自动热更新。</p>
<h2>自定义 mdx 组件</h2>
<p>上面代码已经实现了在 md 文档中显示组件和代码，但我们想要的是类似于 ant design 那样的效果，默认代码不展示，点击可以收起和展开，这该怎么实现呢？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57b68b7a21b9461b8ba0b5f2a449900b~tplv-k3u1fbpfcp-zoom-1.image" alt="ant design 代码块"></p>
<p>我们可以利用 mdx 的自定义组件来实现这个效果。</p>
<p>写 mdx 的时候，在组件 <code>&#x3C;Login/></code>和代码外层嵌套一个自定义组件<code>DemoBlock</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21bc9aabd9644cfdada4b7dcbab8d052~tplv-k3u1fbpfcp-zoom-1.image" alt="markdown 信息"></p>
<p>然后实现一个自定义一个 <code>DemoBlock</code> 组件，提供给 <code>MDXProvider</code>，这样所有的 mdx 文档中，不需要 <code>import</code> 就可以使用组件。</p>
<pre><code>import dynamic from 'next/dynamic'
import { MDXProvider } from '@mdx-js/react'

const DemoBlock = ({ children }: any) => {
  console.log(children)
  return null
}

const components = {
  DemoBlock,
}

export default function Page({ slug }: Props) {
  const Content = dynamic(() => import(`packages/${slug}/docs/index.mdx`), {
    ssr: false,
  })

  return (
    &#x3C;div>
      &#x3C;MDXProvider components={components}>
        &#x3C;Content />
      &#x3C;/MDXProvider>
    &#x3C;/div>
  )
}
</code></pre>
<p>我们先写一个空组件，看下 <code>children</code> 的值。刷新页面， 此时 <code>DemoBlock</code>中的组件和代码不会显示，我们看一下打印出的 <code>children</code> 节点信息；</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f470e8ba82d4936a698d1b5be87f9ce~tplv-k3u1fbpfcp-zoom-1.image" alt=" DemoBlock children 节点数据"></p>
<p>chilren 为 react 中的 vNode，现在我们就可以根据 type 来判断，返回不同的 jsx，这样就可以实现<code>DemoBlock</code>组件了，代码如下：</p>
<pre><code>import React, { useState } from 'react'

const DemoBlock = ({ children }: any) => {
  const [visible, setVisible] = useState(false)

  return (
    &#x3C;div className="demo-block">
      {children.map((child: any) => {
        if (child.type === 'pre') {
          return (
            &#x3C;div key={child.key}>
              &#x3C;div className="demo-block-button" onClick={() => setVisible(!visible)}>
                {!visible ? '显示代码' : '收起代码'}
              &#x3C;/div>
              {visible &#x26;&#x26; child}
            &#x3C;/div>
          )
        }
        return child
      })}
    &#x3C;/div>
  )
}
</code></pre>
<p>再给组件添加一些样式，给按钮添加一个 svg icon，一起来看下实现效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6d414dd5ca94a93be1b07eb2f31d04c~tplv-k3u1fbpfcp-zoom-1.image" alt="组件文档 demo 效果"></p>
<p>是不是有跟 antd 的 demo block 有些相似了呢？ 若要显示更多字段和描述，我们可以修改组件代码，实现完全自定义。</p>
<h2>优化文档界面</h2>
<p>至此我们的文档，还是有些简陋，我们得优化下文档界面，让我们的界面显示更美观。</p>
<ol>
<li>安装并且初始化 tailwindcss</li>
</ol>
<pre><code>pnpm install -Dw tailwindcss postcss autoprefixer @tailwindcss/typography
pnpx tailwindcss init -p
</code></pre>
<p>修改 <code>globals.css</code> 为 tailwindcss 默认指令</p>
<pre><code>@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<p>修改 <code>tailwind.config.js</code> 配置文件，让我们的应用支持文章默认样式，并且在 md 和 mdx 文件中也可以写 tailwindcss</p>
<pre><code>const defaultTheme = require('tailwindcss/defaultTheme')
const colors = require('tailwindcss/colors')

/** @type {import("tailwindcss").Config } */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,md,mdx}',
    './components/**/*.{js,ts,jsx,tsx}',
    './packages/**/*.{md,mdx}',
  ],
  darkMode: 'class',
  plugins: [require('@tailwindcss/typography')],
}
</code></pre>
<p>在 MDX Content 组件 外层可以加一个 <code>prose</code> class，这样我们的文档就有了默认好看文章样式了。</p>
<p>现在 md 文档功能还很薄弱，我们需要让它强大起来，我们先安装一些 markdown 常用的包</p>
<pre><code>pnpm install remark-gfm remark-footnotes remark-math rehype-katex rehype-slug rehype-autolink-headings rehype-prism-plus -w
</code></pre>
<ul>
<li>
<p><code>remark-gfm</code> 让 md 支持 GitHub Flavored Markdown （自动超链接链接文字、脚注、删除线、表格、任务列表）</p>
</li>
<li>
<p><code>remark-math</code> <a href="url">rehype-katex</a> 支持数学公式</p>
</li>
<li>
<p><code>rehype-slug</code> <a href="url">rehype-autolink-headings</a> 自动给标题加唯一 id</p>
</li>
<li>
<p><code>rehype-prism-plus</code> 支持代码高亮</p>
</li>
</ul>
<p>修改 <code>next.config.js</code> 为 <code>next.config.mjs</code>，并输入以下代码</p>
<pre><code>// Remark packages
import remarkGfm from 'remark-gfm'
import remarkFootnotes from 'remark-footnotes'
import remarkMath from 'remark-math'
// Rehype packages
import rehypeSlug from 'rehype-slug'
import rehypeAutolinkHeadings from 'rehype-autolink-headings'
import rehypePrismPlus from 'rehype-prism-plus'

import nextMDX from '@next/mdx'

const withMDX = nextMDX({
  extension: /\.mdx?$/,
  options: {
    remarkPlugins: [remarkMath, remarkGfm, [remarkFootnotes, { inlineNotes: true }]],
    rehypePlugins: [rehypeSlug, rehypeAutolinkHeadings, [rehypePrismPlus, { ignoreMissing: true }]],
  },
})

export default withMDX({
  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],
  reactStrictMode: true,
  swcMinify: true,
})
</code></pre>
<p>我们在这里可以配置 remarkPlugins 和 rehypePlugins；</p>
<p>markdown 在编译过程中会涉及 3 种 ast 抽象语法树 ， remark 负责转换为 mdast，它可以操作 markdown 文件，比如让 markdown 支持更多格式（比如：公式、脚注、任务列表等），需要使用 remark 插件； rehype 负责转换为 hast ，它可以转换 html，比如给 标题加 id，给代码高亮， 这一步是在操作 HTML 后完成的。因此我们也可以自己写插件，具体写什么插件，就要看插件在哪个阶段运行。</p>
<p>最后我们到 github <a href="https://github.com/PrismJS/prism-themes/blob/master/themes/prism-atom-dark.css">prism-themes</a> 中复制一份代码高亮的样式到我们的 css 文件中，一起来看下效果吧！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958db388c7dc45728c2a8b16fd74d3a9~tplv-k3u1fbpfcp-zoom-1.image" alt="组件文档代码高亮"></p>
<h2>发布工作流</h2>
<p>workspace 中的包版本管理是一个复杂的任务，pnpm 目前也并未提供内置的解决方案。pnpm 推荐了两个开源的版本控制工具：changesets 和 rush，这里我采用了 <a href="https://github.com/changesets/changesets" title="changesets">changesets</a> 来实现依赖包的管理。</p>
<h3>配置</h3>
<p>要在 pnpm 工作空间上配置 changesets，请将 changesets 作为开发依赖项安装在工作空间的根目录中：</p>
<pre><code>pnpm add -Dw @changesets/cli
</code></pre>
<p>然后 changesets 的初始化命令：</p>
<pre><code>pnpm changeset init
</code></pre>
<h3>添加新的 changesets</h3>
<p>要生成新的 changesets，请在仓库的根目录中执行<code>pnpm changeset</code>。 <code>.changeset</code> 目录中生成的 markdown 文件需要被提交到到仓库。</p>
<h3>发布变更</h3>
<p>为了方便所有包的发布过程，在工程根目录下的 pacakge.json 的 scripts 中增加如下几条脚本：</p>
<pre><code>"compile": "pnpm --filter=@mastack/* run build",
"pub": "pnpm compile &#x26;&#x26; pnpm --recursive --registry https://registry.npmjs.org/ publish --access public"
</code></pre>
<p>编译阶段，生成构建产物</p>
<ol>
<li>运行<code>pnpm changeset version</code>。 这将提高先前使用 <code>pnpm changeset</code> （以及它们的任何依赖项）的版本，并更新变更日志文件。</li>
<li>运行 <code>pnpm install</code>。 这将更新锁文件并重新构建包。</li>
<li>提交更改。</li>
<li>运行 <code>pnpm pub</code>。 此命令将发布所有包含被更新版本且尚未出现在包注册源中的包。</li>
</ol>
<h2>部署</h2>
<p>部署可以选择 gitbub pages 或者 vercel 部署，他们都是免费的，Github pages 只支持静态网站，vercel 支持动态网站，它会将 nextjs page 中，单独部署成函数的形式。我这里选择使用 vercel，因为它的访问速度相对比 gitbub pages 要快很多。只需要使用 github 账号登录 https://vercel.com/ 导入项目，便会自动部署，而且会自动分配一个 https://xxx.vercel.app/ 二级域名。</p>
<p>也可以使用命令行工具，在项目跟目录下执行，根据提示，选择默认即可</p>
<pre><code>npx vercel
</code></pre>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db59465d9a384b158955a2ed1e69b25d~tplv-k3u1fbpfcp-zoom-1.image" alt="vercel 部署"></p>
<p>预览地址：https://nextjs-components-docs.vercel.app/</p>
<h2>小结</h2>
<p>本文，我们从零开始，使用 Next.js 和 pnpm 搭建了一个组件库文档，主要使用 Next.js 动态导入功能解决了开发服务缓慢的问题，使用 Next.js 的 SSG 模式来生成静态文档。最后我们使用 changesets 来管理包的 version 和生成 changelog。</p>
<p>好了，以上就是本文的全部内容，你学会了吗？接下来我将继续分享 Next.js 相关的实战文章，欢迎各位关注我的《 Next.js 全栈开发实战》 专栏，感谢您的阅读。</p>
</div><div class="items-center"><a href="articles">返回文档列表</a></div></div></div></main></main><footer><div class="mt-16 flex flex-col items-center"><div class="mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400"><div>© 2023</div><div> • </div><a href="/">HAN|博客</a></div></div></footer></div></div><div></div><script src="/_next/static/chunks/webpack-afd6b160f7b2e7a5.js" async=""></script><script src="/_next/static/chunks/2443530c-da705fa45a107f29.js" async=""></script><script src="/_next/static/chunks/139-a98e23425a4dfbf4.js" async=""></script><script src="/_next/static/chunks/main-app-06da1dca58d74c34.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/26351ac1a6eca06c.css\",{\"as\":\"style\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/7f6bd37aab40623f.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":\"7858\",\"chunks\":[\"272:static/chunks/webpack-afd6b160f7b2e7a5.js\",\"667:static/chunks/2443530c-da705fa45a107f29.js\",\"139:static/chunks/139-a98e23425a4dfbf4.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":\"3055\",\"chunks\":[\"272:static/chunks/webpack-afd6b160f7b2e7a5.js\",\"667:static/chunks/2443530c-da705fa45a107f29.js\",\"139:static/chunks/139-a98e23425a4dfbf4.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":\"414\",\"chunks\":[\"414:static/chunks/414-4c4d64a76277ff85.js\",\"345:static/chunks/app/articles/page/[slug]/page-b019257b"])</script><script>self.__next_f.push([1,"db7591a1.js\"],\"name\":\"\",\"async\":false}\n8:I{\"id\":\"9544\",\"chunks\":[\"272:static/chunks/webpack-afd6b160f7b2e7a5.js\",\"667:static/chunks/2443530c-da705fa45a107f29.js\",\"139:static/chunks/139-a98e23425a4dfbf4.js\"],\"name\":\"\",\"async\":false}\n9:I{\"id\":\"99\",\"chunks\":[\"272:static/chunks/webpack-afd6b160f7b2e7a5.js\",\"667:static/chunks/2443530c-da705fa45a107f29.js\",\"139:static/chunks/139-a98e23425a4dfbf4.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":\"1389\",\"chunks\":[\"120:static/chunks/120-384f50ccf38e1ade.js\",\"70:static/chunks/a"])</script><script>self.__next_f.push([1,"pp/articles/layout-8324812b78a65603.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/26351ac1a6eca06c.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/articles/monorepo\",\"initialTree\":[\"\",{\"children\":[\"articles\",{\"children\":[[\"slug\",\"monorepo\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"monorepo\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[\"$L5\",null],\"globalErrorComponent\":\"$6\",\"notFound\":[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"className\":\"scroll-smooth dark\",\"children\":[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"h-screen flex flex-col justify-between\",\"children\":[[\"$\",\"header\",null,{\"className\":\"flex items-center justify-around py-10\",\"children\":[[\"$\",\"div\",null,{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between\",\"children\":[\"$\",\"div\",null,{\"className\":\"hidden h-6 text-2xl font-semibold sm:block\",\"children\":[\"$\",\"a\",null,{\"children\":\"HAN个人博客\"}]}]}]}]}],[\"$\",\"div\",null,{\"className\":\"flex items-center text-base leading-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"hidden sm:block\",\"children\":[[\"$\",\"$L7\",\"/\",{\"href\":\"/\",\"className\":\"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4\",\"children\":\"主页\"}],[\"$\",\"$L7\",\"/articles\",{\"href\":\"/articles\",\"className\":\"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4\",\"children\":\"文章\"}],[\"$\",\"$L7\",\"/about\",{\"href\":\"/about\",\"className\":\"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4\",\"children\":\"关于\"}]]}]}],[\"$\",\"div\",null,{}]]}],[\"$\",\"main\",null,{\"className\":\"mb-auto\",\"children\":[[],[\"$\",\"div\",null,{\"className\":\"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"space-x-2 pt-6 pb-8 md:space-y-5\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14\",\"children\":\"404\"}]}],[\"$\",\"div\",null,{\"className\":\"max-w-md\",\"children\":[[\"$\",\"p\",null,{\"className\":\"mb-4 text-xl font-bold leading-normal md:text-2xl\",\"children\":\"抱歉，这个页面暂时没找到\"}],[\"$\",\"p\",null,{\"className\":\"mb-8\",\"children\":\"别急，您可以可以返回首页找找！\"}],[\"$\",\"$L7\",null,{\"href\":\"/\",\"children\":[\"$\",\"button\",null,{\"className\":\"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500\",\"children\":\"返回主页\"}]}]]}]]}]]}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"mt-16 flex flex-col items-center\",\"children\":[\"$\",\"div\",null,{\"className\":\"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400\",\"children\":[[\"$\",\"div\",null,{\"children\":\"© 2023\"}],[\"$\",\"div\",null,{\"children\":\" • \"}],[\"$\",\"$L7\",null,{\"href\":\"/\",\"children\":\"HAN|博客\"}]]}]}]}]]}]}],[\"$\",\"div\",null,{}]]}]]}],\"asNotFound\":false,\"children\":[[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"className\":\"scroll-smooth dark\",\"children\":[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"h-screen flex flex-col justify-between\",\"children\":[[\"$\",\"header\",null,{\"className\":\"flex items-center justify-around py-10\",\"children\":[[\"$\",\"div\",null,{\"children\":[\"$\",\"$L7\",null,{\"href\":\"/\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between\",\"children\":[\"$\",\"div\",null,{\"className\":\"hidden h-6 text-2xl font-semibold sm:block\",\"children\":[\"$\",\"a\",null,{\"children\":\"HAN个人博客\"}]}]}]}]}],[\"$\",\"div\",null,{\"className\":\"flex items-center text-base leading-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"hidden sm:block\",\"children\":[[\"$\",\"$L7\",\"/\",{\"href\":\"/\",\"className\":\"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4\",\"children\":\"主页\"}],[\"$\",\"$L7\",\"/articles\",{\"href\":\"/articles\",\"className\":\"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4\",\"children\":\"文章\"}],[\"$\",\"$L7\",\"/about\",{\"href\":\"/about\",\"className\":\"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4\",\"children\":\"关于\"}]]}]}],[\"$\",\"div\",null,{}]]}],[\"$\",\"main\",null,{\"className\":\"mb-auto\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"space-x-2 pt-6 pb-8 md:space-y-5\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14\",\"children\":\"404\"}]}],[\"$\",\"div\",null,{\"className\":\"max-w-md\",\"children\":[[\"$\",\"p\",null,{\"className\":\"mb-4 text-xl font-bold leading-normal md:text-2xl\",\"children\":\"抱歉，这个页面暂时没找到\"}],[\"$\",\"p\",null,{\"className\":\"mb-8\",\"children\":\"别急，您可以可以返回首页找找！\"}],[\"$\",\"$L7\",null,{\"href\":\"/\",\"children\":[\"$\",\"button\",null,{\"className\":\"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500\",\"children\":\"返回主页\"}]}]]}]]}],\"notFoundStyles\":[],\"asNotFound\":false,\"childProp\":{\"current\":[[\"$\",\"$La\",null,{\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"articles\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"articles\",\"children\",[\"slug\",\"monorepo\",\"d\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"asNotFound\":false,\"childProp\":{\"current\":[\"$Lb\",null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"monorepo\\\"}\"},\"styles\":[]}],\"segment\":[\"slug\",\"monorepo\",\"d\"]},\"styles\":[]}],\"params\":{}}],null],\"segment\":\"articles\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7f6bd37aab40623f.css\",\"precedence\":\"next\"}]]}]}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"mt-16 flex flex-col items-center\",\"children\":[\"$\",\"div\",null,{\"className\":\"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400\",\"children\":[[\"$\",\"div\",null,{\"children\":\"© 2023\"}],[\"$\",\"div\",null,{\"children\":\" • \"}],[\"$\",\"$L7\",null,{\"href\":\"/\",\"children\":\"HAN|博客\"}]]}]}]}]]}]}],[\"$\",\"div\",null,{}]]}]]}],null]}]]\n"])</script><script>self.__next_f.push([1,"b:[\"$\",\"div\",null,{\"className\":\"flex justify-center\",\"children\":[\"$\",\"div\",null,{\"className\":\"prose dark:prose-invert mt-10\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"使用 Next.js 搭建 Monorepo 组件库文档\"}],[\"$\",\"div\",null,{\"className\":\"items-center\",\"children\":[\"$\",\"$L7\",null,{\"href\":\"articles\",\"children\":\"返回文档列表\"}]}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cblockquote\u003e\\n\u003cp\u003e文章为稀土掘金技术社区首发签约文章，14 天内禁止转载，14 天后未获授权禁止转载，侵权必究！\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003ch2\u003e阅读本文你将：\u003c/h2\u003e\\n\u003cul\u003e\\n\u003cli\u003e使用 pnpm 搭建一个 Monorepo 组件库\u003c/li\u003e\\n\u003cli\u003e使用 Next.js 开发一个组件库文档\u003c/li\u003e\\n\u003cli\u003echangesets 来管理包的 version 和生成 changelog\u003c/li\u003e\\n\u003cli\u003e使用 vercel 部署在线文档\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003e代码仓库：https://github.com/maqi1520/nextjs-components-docs\u003c/p\u003e\\n\u003ch2\u003e前言\u003c/h2\u003e\\n\u003cp\u003e组件化开发是前端的基石，正因为组件化，前端得以百花齐放，百家争鸣。我们每天在项目中都写着各种各样的组件，如果在面试的时候，跟面试官说，你每天的工作是开发组件，那么显然这没有什么优势，如果你说，你开发了一个组件库，并且有一个在线文档可以直接预览，这可能会是你的一个加分项。今天我们就来聊聊组件库的开发，主要是组件库的搭建和文档建设，至于组件数量，那是时间问题，以及你是否有时间维护好这个组件库的问题。\u003c/p\u003e\\n\u003ch2\u003e基础组件和业务组件\u003c/h2\u003e\\n\u003cp\u003e首先组件库分为基础组件和业务组件，所谓基础组件就是 UI 组件，类似 Ant design，它是单包架构，所有的组件都是在一个包中，一旦其中一个组件有改动，就需要发整包。另外一种是业务组件，组件中包含了一些业务逻辑，它在企业内部是很有必要的。比如飞书文档，包含在线文档，在线 PPT、视频会议等，这些都是独立的产品，单独迭代开发，单独发布，却有一些共同的逻辑，比如没有登录的时候都需要调用一个”登录弹窗“，或者说在项目协同的时候，都需要邀请人员加入，那么需要一个“人员选择组件”， 这就是业务组件。业务组件不同于基础组件，单独安装，依赖发包，而并不是全量发包。那么这些业务组件也需要一个文档，因此我们使用 Monorepo（单仓库管理），这样方便管理和维护。\u003c/p\u003e\\n\u003ch2\u003e为什么选用 Next.js 来搭建组件库文档？\u003c/h2\u003e\\n\u003cp\u003e组件文档有个特别重要的功能就是“写 markdown 文档，可以看到代码以及运行效果”，这方面有很多优秀的开源库，比如 Ant design 使用的是 \u003ca href=\\\"https://github.com/benjycui/bisheng\\\" title=\\\"bisheng\\\"\u003ebisheng\u003c/a\u003e， react use 使用的是 \u003ca href=\\\"https://github.com/storybookjs/storybook\\\" title=\\\"storybook\\\"\u003estorybook\u003c/a\u003e， 还有一些优秀的库，比如：\u003ca href=\\\"https://github.com/umijs/dumi\\\" title=\\\"dumi\\\"\u003edumi\u003c/a\u003e，\u003ca href=\\\"https://github.com/doczjs/docz\\\" title=\\\"docz\\\"\u003eDocz\u003c/a\u003e 等。 本地跑过 Ant design 的同学都知道， Ant design 的启动速度非常慢，因为底层使用的 webpack，要启动开发服务器，必须将所有组件都进行编译，这会对开发者造成一些困扰，因为如果是业务组件的话，开发者只关注单个组件，而不是全部组件。而使用 Next.jz 就有 2 个非常大的优势：\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e使用 swc 编译，Next.js 中实现了快 3 倍的快速刷新和快 5 倍的构建速度；\u003c/li\u003e\\n\u003cli\u003e按需编译，在开发环境下，只有访问的页面才会进行编译\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003e那么接下来的问题就是：要在 Next.js 中实现 “写 Markdown Example 可预览”的功能，若要自己实现这个功能，确实是一件麻烦的事情。我们换一个思维，组件展示，也就是在 markdown 中运行 react 组件，这不就是 \u003ca href=\\\"https://github.com/mdx-js/mdx\\\" title=\\\"mdx\\\"\u003emdx\u003c/a\u003e 的功能吗？ 而在 Next.js 中可以很方便地集成 MDX。\u003c/p\u003e\\n\u003ch2\u003e效果演示  \u003c/h2\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dc62765c903439ea4654ef5f1dcd646~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"实现效果\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e目前这是一个简易版，只为展示 Next.js 搭建文档\u003c/p\u003e\\n\u003ch2\u003e项目初始化\u003c/h2\u003e\\n\u003cp\u003e首先我们创建一个 next typescript 作为我们项目的主目录，用于组件库的文档开发\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003enpx create-next-app@latest --ts\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e要想启动 pnpm 的 workspace 功能，需要工程根目录下存在 \u003ccode\u003epnpm-workspace.yaml\u003c/code\u003e 配置文件，并且在 \u003ccode\u003epnpm-workspace.yaml\u003c/code\u003e 中指定工作空间的目录。比如这里我们所有的子包都是放在 packages 目录下\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003epackages:\\n  - 'packages/*'\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e接下来，我们在 packages 文件夹下创建三个子项目，分别是：user-select、login 和 utils， 对应用户选择，登录 和工具类。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e├── packages\\n│   ├── user-select\\n│   ├── login\\n│   ├── utils\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003euser-select 和 login 依赖 utils，我们可以将一些公用方法放到 utils 中。\u003c/p\u003e\\n\u003cp\u003e给每个 package 下面创建 \u003ccode\u003epackage.json\u003c/code\u003e 文件，包名称通常是”@命名空间+包名@“的方式，比如@vite/xx 或@babel/xx，在本例中，这里我们都以\u003ccode\u003e@mastack\u003c/code\u003e开头\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e{\\n  \\\"name\\\": \\\"@mastack/login\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"\\\",\\n  \\\"main\\\": \\\"dist/index.js\\\",\\n  \\\"types\\\": \\\"dist/index.d.ts\\\",\\n  \\\"scripts\\\": {\\n    \\\"build\\\": \\\"tsc\\\"\\n  },\\n  \\\"keywords\\\": [],\\n  \\\"author\\\": \\\"\\\",\\n  \\\"license\\\": \\\"ISC\\\"\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e给每个 package 安装 typescript\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003epnpm add typescript -r  -D\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e给每个 package 创建 tsconfig.json 文件\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e{\\n  \\\"include\\\": [\\\"src/**/*\\\"],\\n  \\\"compilerOptions\\\": {\\n    \\\"jsx\\\": \\\"react\\\",\\n    \\\"outDir\\\": \\\"dist\\\",\\n    \\\"target\\\": \\\"ES2020\\\",\\n    \\\"module\\\": \\\"esnext\\\",\\n    \\\"strict\\\": true,\\n    \\\"esModuleInterop\\\": true,\\n    \\\"skipLibCheck\\\": true,\\n    \\\"moduleResolution\\\": \\\"node\\\",\\n    \\\"declaration\\\": true,\\n    \\\"forceConsistentCasingInFileNames\\\": true\\n  }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e执行下面代码，往 login 组件中安装 utils;\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003epnpm i @mastack/utils --filter @mastack/login\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e安装完成后，设置依赖版本的时候推荐用 \u003ccode\u003eworkspace:*\u003c/code\u003e，就可以保持依赖的版本是工作空间里最新版本，不需要每次手动更新依赖版本。\u003c/p\u003e\\n\u003cp\u003epnpm 提供了 \u003ccode\u003e-w\u003c/code\u003e, \u003ccode\u003e--workspace-root\u003c/code\u003e 参数，可以将依赖包安装到工程的根目录下，作为所有 package 的公共依赖，这么我们安装 \u003ccode\u003eantd\u003c/code\u003e\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003epnpm install antd -w\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003ch2\u003e组件开发\u003c/h2\u003e\\n\u003cp\u003e我们在 login 组件下，新建一个组件 \u003ccode\u003esrc/index.tsx\u003c/code\u003e\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003eimport React, { useState } from 'react'\\nimport { Button, Modal } from 'antd'\\n\\ninterface Props {\\n  className: string;\\n}\\n\\nexport default function Login({ className }: Props) {\\n  const [open, setopen] = useState(false)\\n  return (\\n    \u0026#x3C;\u003e\\n      \u0026#x3C;Button onClick={() =\u003e setopen(true)} className={className}\u003e\\n        登录\\n      \u0026#x3C;/Button\u003e\\n      \u0026#x3C;Modal title=\\\"登录\\\" open={open} onCancel={() =\u003e setopen(false)} onOk={() =\u003e setopen(false)}\u003e\\n        \u0026#x3C;p\u003e登录弹窗\u0026#x3C;/p\u003e\\n      \u0026#x3C;/Modal\u003e\\n    \u0026#x3C;/\u003e\\n  )\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e先写一个最简单版本，组件代码并不是最重要的，后续可以再优化。\u003c/p\u003e\\n\u003cp\u003e在 package.json 中添加构建命令\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e\\\"scripts\\\": {\\n    \\\"build\\\": \\\"tsc\\\"\\n  }\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e然后在组件目录下执行 \u003ccode\u003eyarn build\u003c/code\u003e 。此时组件以及可以打包成功！\u003c/p\u003e\\n\u003ch2\u003eNext.js 支持 MDX\u003c/h2\u003e\\n\u003cp\u003e接下来要让文档支持 MDX，在根目录下执行以下命令，安装 mdx 和 loader 相关包\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003epnpm add @next/mdx @mdx-js/loader @mdx-js/react -w\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e修改 \u003ccode\u003enext.config.js\u003c/code\u003e 为以下代码\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003econst withMDX = require('@next/mdx')({\\n  extension: /\\\\.mdx?$/,\\n})\\n\\nmodule.exports = withMDX({\\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\\n  reactStrictMode: true,\\n  swcMinify: true,\\n})\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e这样就可以在 Next 中支持 MDX 了。\u003c/p\u003e\\n\u003cp\u003e我们在 \u003ccode\u003esrc/pages\u003c/code\u003e 目录下，新建一个 \u003ccode\u003edocs/index.mdx\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47e827c0dfbb4623875c4b9e16206471~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"markdown 信息\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e先写一个简单的 markdown 文件测试下\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30f3a4c0bcad4fe782d1fe0b5594d873~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"markdown 渲染\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e这样 Next.js 就支持 mdx 文档了。\u003c/p\u003e\\n\u003ch2\u003eNext 动态加载 md 文件\u003c/h2\u003e\\n\u003cp\u003e接下来，我们要实现动态加载 packages 中的文件 md 文件。新建一个 \u003ccode\u003epages/docs/[...slug].tsx\u003c/code\u003e 文件。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003eexport async function getStaticPaths(context: GetStaticPathsContext) {\\n  return {\\n    paths: [{ params: { slug: ['login'] } }, { params: { slug: ['user-selecter'] } }],\\n    fallback: false, // SSG 模式\\n  }\\n}\\n\\nexport async function getStaticProps({ params }: GetStaticPropsContext\u0026#x3C;{ slug: string[] }\u003e) {\\n  const slug = params?.slug.join('/')\\n\\n  return {\\n    props: {\\n      slug,\\n    }, // 传递给组件的props\\n  }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e我们使用的是 SSG 模式。上面代码中 \u003ccode\u003egetStaticPaths\u003c/code\u003e 我先写了 2 条数据，因为我们目前只有 2 个组件，它会在构建的时候会生成静态页面。 \u003ccode\u003egetStaticProps\u003c/code\u003e函数可以获取 URL 上的参数，我们将 slug 参数传递给组件，然后在 Page 函数中，我们使用 \u003ccode\u003enext/dynamic\u003c/code\u003e 动态加载 packages 中的 mdx 文件\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003eimport React from 'react'\\nimport { GetStaticPathsContext, InferGetServerSidePropsType, GetStaticPropsContext } from 'next'\\nimport dynamic from 'next/dynamic'\\n\\ntype Props = InferGetServerSidePropsType\u0026#x3C;typeof getStaticProps\u003e\\n\\nexport default function Page({ slug }: Props) {\\n  const Content = dynamic(() =\u003e import(`../packages/${slug}/docs/index.mdx`), {\\n    ssr: false,\\n  })\\n\\n  return (\\n    \u0026#x3C;div\u003e\\n      \u0026#x3C;Content /\u003e\\n    \u0026#x3C;/div\u003e\\n  )\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e此时我们访问 \u003ccode\u003ehttp://localhost:3000/docs/login\u003c/code\u003e 查看效果\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a084dc67f5f84f72b22af0c99e451d78~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"Next.js 编译报错\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e在页面上会提示，无法找到\u003ccode\u003e@mastack/login\u003c/code\u003e 这个包，我们需要在项目的根目录下的 \u003ccode\u003etsconfig.json\u003c/code\u003e 中加入别名\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e{\\n  \\\"compilerOptions\\\": {\\n    \\\"paths\\\": {\\n      \\\"@/*\\\": [\\\"./src/*\\\"],\\n      \\\"@mastack/login\\\": [\\\"packages/login/src\\\"],\\n      \\\"@mastack/user-select\\\": [\\\"packages/user-select/src\\\"]\\n    }\\n  }\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e保存后，页面会自动刷新，我们就可以在页面上看到如下效果。\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e97447d2968a46c89d1f63f1c9883d83~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"Next.js  动态加载 mdx\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e至此文档与 packages 目录下的 mdx 已经打通。修改 \u003ccode\u003epackages/login/docs/index.mdx\u003c/code\u003e 中的文档，页面会自动热更新。\u003c/p\u003e\\n\u003ch2\u003e自定义 mdx 组件\u003c/h2\u003e\\n\u003cp\u003e上面代码已经实现了在 md 文档中显示组件和代码，但我们想要的是类似于 ant design 那样的效果，默认代码不展示，点击可以收起和展开，这该怎么实现呢？\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57b68b7a21b9461b8ba0b5f2a449900b~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"ant design 代码块\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e我们可以利用 mdx 的自定义组件来实现这个效果。\u003c/p\u003e\\n\u003cp\u003e写 mdx 的时候，在组件 \u003ccode\u003e\u0026#x3C;Login/\u003e\u003c/code\u003e和代码外层嵌套一个自定义组件\u003ccode\u003eDemoBlock\u003c/code\u003e\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21bc9aabd9644cfdada4b7dcbab8d052~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"markdown 信息\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e然后实现一个自定义一个 \u003ccode\u003eDemoBlock\u003c/code\u003e 组件，提供给 \u003ccode\u003eMDXProvider\u003c/code\u003e，这样所有的 mdx 文档中，不需要 \u003ccode\u003eimport\u003c/code\u003e 就可以使用组件。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003eimport dynamic from 'next/dynamic'\\nimport { MDXProvider } from '@mdx-js/react'\\n\\nconst DemoBlock = ({ children }: any) =\u003e {\\n  console.log(children)\\n  return null\\n}\\n\\nconst components = {\\n  DemoBlock,\\n}\\n\\nexport default function Page({ slug }: Props) {\\n  const Content = dynamic(() =\u003e import(`packages/${slug}/docs/index.mdx`), {\\n    ssr: false,\\n  })\\n\\n  return (\\n    \u0026#x3C;div\u003e\\n      \u0026#x3C;MDXProvider components={components}\u003e\\n        \u0026#x3C;Content /\u003e\\n      \u0026#x3C;/MDXProvider\u003e\\n    \u0026#x3C;/div\u003e\\n  )\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e我们先写一个空组件，看下 \u003ccode\u003echildren\u003c/code\u003e 的值。刷新页面， 此时 \u003ccode\u003eDemoBlock\u003c/code\u003e中的组件和代码不会显示，我们看一下打印出的 \u003ccode\u003echildren\u003c/code\u003e 节点信息；\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f470e8ba82d4936a698d1b5be87f9ce~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\" DemoBlock children 节点数据\\\"\u003e\u003c/p\u003e\\n\u003cp\u003echilren 为 react 中的 vNode，现在我们就可以根据 type 来判断，返回不同的 jsx，这样就可以实现\u003ccode\u003eDemoBlock\u003c/code\u003e组件了，代码如下：\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003eimport React, { useState } from 'react'\\n\\nconst DemoBlock = ({ children }: any) =\u003e {\\n  const [visible, setVisible] = useState(false)\\n\\n  return (\\n    \u0026#x3C;div className=\\\"demo-block\\\"\u003e\\n      {children.map((child: any) =\u003e {\\n        if (child.type === 'pre') {\\n          return (\\n            \u0026#x3C;div key={child.key}\u003e\\n              \u0026#x3C;div className=\\\"demo-block-button\\\" onClick={() =\u003e setVisible(!visible)}\u003e\\n                {!visible ? '显示代码' : '收起代码'}\\n              \u0026#x3C;/div\u003e\\n              {visible \u0026#x26;\u0026#x26; child}\\n            \u0026#x3C;/div\u003e\\n          )\\n        }\\n        return child\\n      })}\\n    \u0026#x3C;/div\u003e\\n  )\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e再给组件添加一些样式，给按钮添加一个 svg icon，一起来看下实现效果：\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6d414dd5ca94a93be1b07eb2f31d04c~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"组件文档 demo 效果\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e是不是有跟 antd 的 demo block 有些相似了呢？ 若要显示更多字段和描述，我们可以修改组件代码，实现完全自定义。\u003c/p\u003e\\n\u003ch2\u003e优化文档界面\u003c/h2\u003e\\n\u003cp\u003e至此我们的文档，还是有些简陋，我们得优化下文档界面，让我们的界面显示更美观。\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e安装并且初始化 tailwindcss\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cpre\u003e\u003ccode\u003epnpm install -Dw tailwindcss postcss autoprefixer @tailwindcss/typography\\npnpx tailwindcss init -p\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e修改 \u003ccode\u003eglobals.css\u003c/code\u003e 为 tailwindcss 默认指令\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e修改 \u003ccode\u003etailwind.config.js\u003c/code\u003e 配置文件，让我们的应用支持文章默认样式，并且在 md 和 mdx 文件中也可以写 tailwindcss\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003econst defaultTheme = require('tailwindcss/defaultTheme')\\nconst colors = require('tailwindcss/colors')\\n\\n/** @type {import(\\\"tailwindcss\\\").Config } */\\nmodule.exports = {\\n  content: [\\n    './pages/**/*.{js,ts,jsx,tsx,md,mdx}',\\n    './components/**/*.{js,ts,jsx,tsx}',\\n    './packages/**/*.{md,mdx}',\\n  ],\\n  darkMode: 'class',\\n  plugins: [require('@tailwindcss/typography')],\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e在 MDX Content 组件 外层可以加一个 \u003ccode\u003eprose\u003c/code\u003e class，这样我们的文档就有了默认好看文章样式了。\u003c/p\u003e\\n\u003cp\u003e现在 md 文档功能还很薄弱，我们需要让它强大起来，我们先安装一些 markdown 常用的包\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003epnpm install remark-gfm remark-footnotes remark-math rehype-katex rehype-slug rehype-autolink-headings rehype-prism-plus -w\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cul\u003e\\n\u003cli\u003e\\n\u003cp\u003e\u003ccode\u003eremark-gfm\u003c/code\u003e 让 md 支持 GitHub Flavored Markdown （自动超链接链接文字、脚注、删除线、表格、任务列表）\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\\n\u003cp\u003e\u003ccode\u003eremark-math\u003c/code\u003e \u003ca href=\\\"url\\\"\u003erehype-katex\u003c/a\u003e 支持数学公式\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\\n\u003cp\u003e\u003ccode\u003erehype-slug\u003c/code\u003e \u003ca href=\\\"url\\\"\u003erehype-autolink-headings\u003c/a\u003e 自动给标题加唯一 id\u003c/p\u003e\\n\u003c/li\u003e\\n\u003cli\u003e\\n\u003cp\u003e\u003ccode\u003erehype-prism-plus\u003c/code\u003e 支持代码高亮\u003c/p\u003e\\n\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003e修改 \u003ccode\u003enext.config.js\u003c/code\u003e 为 \u003ccode\u003enext.config.mjs\u003c/code\u003e，并输入以下代码\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e// Remark packages\\nimport remarkGfm from 'remark-gfm'\\nimport remarkFootnotes from 'remark-footnotes'\\nimport remarkMath from 'remark-math'\\n// Rehype packages\\nimport rehypeSlug from 'rehype-slug'\\nimport rehypeAutolinkHeadings from 'rehype-autolink-headings'\\nimport rehypePrismPlus from 'rehype-prism-plus'\\n\\nimport nextMDX from '@next/mdx'\\n\\nconst withMDX = nextMDX({\\n  extension: /\\\\.mdx?$/,\\n  options: {\\n    remarkPlugins: [remarkMath, remarkGfm, [remarkFootnotes, { inlineNotes: true }]],\\n    rehypePlugins: [rehypeSlug, rehypeAutolinkHeadings, [rehypePrismPlus, { ignoreMissing: true }]],\\n  },\\n})\\n\\nexport default withMDX({\\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\\n  reactStrictMode: true,\\n  swcMinify: true,\\n})\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e我们在这里可以配置 remarkPlugins 和 rehypePlugins；\u003c/p\u003e\\n\u003cp\u003emarkdown 在编译过程中会涉及 3 种 ast 抽象语法树 ， remark 负责转换为 mdast，它可以操作 markdown 文件，比如让 markdown 支持更多格式（比如：公式、脚注、任务列表等），需要使用 remark 插件； rehype 负责转换为 hast ，它可以转换 html，比如给 标题加 id，给代码高亮， 这一步是在操作 HTML 后完成的。因此我们也可以自己写插件，具体写什么插件，就要看插件在哪个阶段运行。\u003c/p\u003e\\n\u003cp\u003e最后我们到 github \u003ca href=\\\"https://github.com/PrismJS/prism-themes/blob/master/themes/prism-atom-dark.css\\\"\u003eprism-themes\u003c/a\u003e 中复制一份代码高亮的样式到我们的 css 文件中，一起来看下效果吧！\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958db388c7dc45728c2a8b16fd74d3a9~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"组件文档代码高亮\\\"\u003e\u003c/p\u003e\\n\u003ch2\u003e发布工作流\u003c/h2\u003e\\n\u003cp\u003eworkspace 中的包版本管理是一个复杂的任务，pnpm 目前也并未提供内置的解决方案。pnpm 推荐了两个开源的版本控制工具：changesets 和 rush，这里我采用了 \u003ca href=\\\"https://github.com/changesets/changesets\\\" title=\\\"changesets\\\"\u003echangesets\u003c/a\u003e 来实现依赖包的管理。\u003c/p\u003e\\n\u003ch3\u003e配置\u003c/h3\u003e\\n\u003cp\u003e要在 pnpm 工作空间上配置 changesets，请将 changesets 作为开发依赖项安装在工作空间的根目录中：\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003epnpm add -Dw @changesets/cli\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e然后 changesets 的初始化命令：\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003epnpm changeset init\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003ch3\u003e添加新的 changesets\u003c/h3\u003e\\n\u003cp\u003e要生成新的 changesets，请在仓库的根目录中执行\u003ccode\u003epnpm changeset\u003c/code\u003e。 \u003ccode\u003e.changeset\u003c/code\u003e 目录中生成的 markdown 文件需要被提交到到仓库。\u003c/p\u003e\\n\u003ch3\u003e发布变更\u003c/h3\u003e\\n\u003cp\u003e为了方便所有包的发布过程，在工程根目录下的 pacakge.json 的 scripts 中增加如下几条脚本：\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e\\\"compile\\\": \\\"pnpm --filter=@mastack/* run build\\\",\\n\\\"pub\\\": \\\"pnpm compile \u0026#x26;\u0026#x26; pnpm --recursive --registry https://registry.npmjs.org/ publish --access public\\\"\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e编译阶段，生成构建产物\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e运行\u003ccode\u003epnpm changeset version\u003c/code\u003e。 这将提高先前使用 \u003ccode\u003epnpm changeset\u003c/code\u003e （以及它们的任何依赖项）的版本，并更新变更日志文件。\u003c/li\u003e\\n\u003cli\u003e运行 \u003ccode\u003epnpm install\u003c/code\u003e。 这将更新锁文件并重新构建包。\u003c/li\u003e\\n\u003cli\u003e提交更改。\u003c/li\u003e\\n\u003cli\u003e运行 \u003ccode\u003epnpm pub\u003c/code\u003e。 此命令将发布所有包含被更新版本且尚未出现在包注册源中的包。\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003ch2\u003e部署\u003c/h2\u003e\\n\u003cp\u003e部署可以选择 gitbub pages 或者 vercel 部署，他们都是免费的，Github pages 只支持静态网站，vercel 支持动态网站，它会将 nextjs page 中，单独部署成函数的形式。我这里选择使用 vercel，因为它的访问速度相对比 gitbub pages 要快很多。只需要使用 github 账号登录 https://vercel.com/ 导入项目，便会自动部署，而且会自动分配一个 https://xxx.vercel.app/ 二级域名。\u003c/p\u003e\\n\u003cp\u003e也可以使用命令行工具，在项目跟目录下执行，根据提示，选择默认即可\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003enpx vercel\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db59465d9a384b158955a2ed1e69b25d~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"vercel 部署\\\"\u003e\u003c/p\u003e\\n\u003cp\u003e预览地址：https://nextjs-components-docs.vercel.app/\u003c/p\u003e\\n\u003ch2\u003e小结\u003c/h2\u003e\\n\u003cp\u003e本文，我们从零开始，使用 Next.js 和 pnpm 搭建了一个组件库文档，主要使用 Next.js 动态导入功能解决了开发服务缓慢的问题，使用 Next.js 的 SSG 模式来生成静态文档。最后我们使用 changesets 来管理包的 version 和生成 changelog。\u003c/p\u003e\\n\u003cp\u003e好了，以上就是本文的全部内容，你学会了吗？接下来我将继续分享 Next.js 相关的实战文章，欢迎各位关注我的《 Next.js 全栈开发实战》 专栏，感谢您的阅读。\u003c/p\u003e\\n\"}}],[\"$\",\"div\",null,{\"className\":\"items-center\",\"children\":[\"$\",\"$L7\",null,{\"href\":\"articles\",\"children\":\"返回文档列表\"}]}]]}]}]\n"])</script><script>self.__next_f.push([1,"5:[[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],[\"$\",\"title\",null,{\"children\":\"HAN Blog\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"Created by HAN\"}],null,null,null,null,null,null,null,null,[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"\\\\favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"any\"}]],[],null]]\n"])</script>