1:HL["/_next/static/css/26351ac1a6eca06c.css",{"as":"style"}]
0:[[["",{"children":["articles",{"children":[["slug","monorepo","d"],{"children":["__PAGE__?{\"slug\":\"monorepo\"}",{}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/26351ac1a6eca06c.css","precedence":"next"}]],["$L3",null]]]]
4:HL["/_next/static/css/7f6bd37aab40623f.css",{"as":"style"}]
5:I{"id":"414","chunks":["414:static/chunks/414-4c4d64a76277ff85.js","345:static/chunks/app/articles/page/[slug]/page-b019257bdb7591a1.js"],"name":"","async":false}
6:I{"id":"9544","chunks":["272:static/chunks/webpack-afd6b160f7b2e7a5.js","667:static/chunks/2443530c-da705fa45a107f29.js","139:static/chunks/139-a98e23425a4dfbf4.js"],"name":"","async":false}
7:I{"id":"99","chunks":["272:static/chunks/webpack-afd6b160f7b2e7a5.js","667:static/chunks/2443530c-da705fa45a107f29.js","139:static/chunks/139-a98e23425a4dfbf4.js"],"name":"","async":false}
8:I{"id":"1389","chunks":["120:static/chunks/120-384f50ccf38e1ade.js","70:static/chunks/app/articles/layout-8324812b78a65603.js"],"name":"","async":false}
2:[["$","html",null,{"lang":"zh-CN","className":"scroll-smooth dark","children":[["$","meta",null,{"charSet":"utf-8"}],["$","body",null,{"children":[["$","div",null,{"className":"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0","children":["$","div",null,{"className":"h-screen flex flex-col justify-between","children":[["$","header",null,{"className":"flex items-center justify-around py-10","children":[["$","div",null,{"children":["$","$L5",null,{"href":"/","children":["$","div",null,{"className":"flex items-center justify-between","children":["$","div",null,{"className":"hidden h-6 text-2xl font-semibold sm:block","children":["$","a",null,{"children":"HAN个人博客"}]}]}]}]}],["$","div",null,{"className":"flex items-center text-base leading-5","children":["$","div",null,{"className":"hidden sm:block","children":[["$","$L5","/",{"href":"/","className":"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4","children":"主页"}],["$","$L5","/articles",{"href":"/articles","className":"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4","children":"文章"}],["$","$L5","/about",{"href":"/about","className":"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4","children":"关于"}]]}]}],["$","div",null,{}]]}],["$","main",null,{"className":"mb-auto","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":["$","div",null,{"className":"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6","children":[["$","div",null,{"className":"space-x-2 pt-6 pb-8 md:space-y-5","children":["$","h1",null,{"className":"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14","children":"404"}]}],["$","div",null,{"className":"max-w-md","children":[["$","p",null,{"className":"mb-4 text-xl font-bold leading-normal md:text-2xl","children":"抱歉，这个页面暂时没找到"}],["$","p",null,{"className":"mb-8","children":"别急，您可以可以返回首页找找！"}],["$","$L5",null,{"href":"/","children":["$","button",null,{"className":"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500","children":"返回主页"}]}]]}]]}],"notFoundStyles":[],"asNotFound":"$undefined","childProp":{"current":[["$","$L8",null,{"children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children",["slug","monorepo","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$L9",null],"segment":"__PAGE__?{\"slug\":\"monorepo\"}"},"styles":[]}],"segment":["slug","monorepo","d"]},"styles":[]}],"params":{}}],null],"segment":"articles"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/7f6bd37aab40623f.css","precedence":"next"}]]}]}],["$","footer",null,{"children":["$","div",null,{"className":"mt-16 flex flex-col items-center","children":["$","div",null,{"className":"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400","children":[["$","div",null,{"children":"© 2023"}],["$","div",null,{"children":" • "}],["$","$L5",null,{"href":"/","children":"HAN|博客"}]]}]}]}]]}]}],["$","div",null,{}]]}]]}],null]
3:[[["$","meta",null,{"charSet":"utf-8"}],["$","title",null,{"children":"HAN Blog"}],["$","meta",null,{"name":"description","content":"Created by HAN"}],null,null,null,null,null,null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[["$","link",null,{"rel":"icon","href":"\\favicon.ico","type":"image/x-icon","sizes":"any"}]],[],null]]
9:["$","div",null,{"className":"flex justify-center","children":["$","div",null,{"className":"prose dark:prose-invert mt-10","children":[["$","h1",null,{"children":"使用 Next.js 搭建 Monorepo 组件库文档"}],["$","div",null,{"className":"items-center","children":["$","$L5",null,{"href":"articles","children":"返回文档列表"}]}],["$","div",null,{"dangerouslySetInnerHTML":{"__html":"<blockquote>\n<p>文章为稀土掘金技术社区首发签约文章，14 天内禁止转载，14 天后未获授权禁止转载，侵权必究！</p>\n</blockquote>\n<h2>阅读本文你将：</h2>\n<ul>\n<li>使用 pnpm 搭建一个 Monorepo 组件库</li>\n<li>使用 Next.js 开发一个组件库文档</li>\n<li>changesets 来管理包的 version 和生成 changelog</li>\n<li>使用 vercel 部署在线文档</li>\n</ul>\n<p>代码仓库：https://github.com/maqi1520/nextjs-components-docs</p>\n<h2>前言</h2>\n<p>组件化开发是前端的基石，正因为组件化，前端得以百花齐放，百家争鸣。我们每天在项目中都写着各种各样的组件，如果在面试的时候，跟面试官说，你每天的工作是开发组件，那么显然这没有什么优势，如果你说，你开发了一个组件库，并且有一个在线文档可以直接预览，这可能会是你的一个加分项。今天我们就来聊聊组件库的开发，主要是组件库的搭建和文档建设，至于组件数量，那是时间问题，以及你是否有时间维护好这个组件库的问题。</p>\n<h2>基础组件和业务组件</h2>\n<p>首先组件库分为基础组件和业务组件，所谓基础组件就是 UI 组件，类似 Ant design，它是单包架构，所有的组件都是在一个包中，一旦其中一个组件有改动，就需要发整包。另外一种是业务组件，组件中包含了一些业务逻辑，它在企业内部是很有必要的。比如飞书文档，包含在线文档，在线 PPT、视频会议等，这些都是独立的产品，单独迭代开发，单独发布，却有一些共同的逻辑，比如没有登录的时候都需要调用一个”登录弹窗“，或者说在项目协同的时候，都需要邀请人员加入，那么需要一个“人员选择组件”， 这就是业务组件。业务组件不同于基础组件，单独安装，依赖发包，而并不是全量发包。那么这些业务组件也需要一个文档，因此我们使用 Monorepo（单仓库管理），这样方便管理和维护。</p>\n<h2>为什么选用 Next.js 来搭建组件库文档？</h2>\n<p>组件文档有个特别重要的功能就是“写 markdown 文档，可以看到代码以及运行效果”，这方面有很多优秀的开源库，比如 Ant design 使用的是 <a href=\"https://github.com/benjycui/bisheng\" title=\"bisheng\">bisheng</a>， react use 使用的是 <a href=\"https://github.com/storybookjs/storybook\" title=\"storybook\">storybook</a>， 还有一些优秀的库，比如：<a href=\"https://github.com/umijs/dumi\" title=\"dumi\">dumi</a>，<a href=\"https://github.com/doczjs/docz\" title=\"docz\">Docz</a> 等。 本地跑过 Ant design 的同学都知道， Ant design 的启动速度非常慢，因为底层使用的 webpack，要启动开发服务器，必须将所有组件都进行编译，这会对开发者造成一些困扰，因为如果是业务组件的话，开发者只关注单个组件，而不是全部组件。而使用 Next.jz 就有 2 个非常大的优势：</p>\n<ul>\n<li>使用 swc 编译，Next.js 中实现了快 3 倍的快速刷新和快 5 倍的构建速度；</li>\n<li>按需编译，在开发环境下，只有访问的页面才会进行编译</li>\n</ul>\n<p>那么接下来的问题就是：要在 Next.js 中实现 “写 Markdown Example 可预览”的功能，若要自己实现这个功能，确实是一件麻烦的事情。我们换一个思维，组件展示，也就是在 markdown 中运行 react 组件，这不就是 <a href=\"https://github.com/mdx-js/mdx\" title=\"mdx\">mdx</a> 的功能吗？ 而在 Next.js 中可以很方便地集成 MDX。</p>\n<h2>效果演示  </h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dc62765c903439ea4654ef5f1dcd646~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"实现效果\"></p>\n<p>目前这是一个简易版，只为展示 Next.js 搭建文档</p>\n<h2>项目初始化</h2>\n<p>首先我们创建一个 next typescript 作为我们项目的主目录，用于组件库的文档开发</p>\n<pre><code>npx create-next-app@latest --ts\n</code></pre>\n<p>要想启动 pnpm 的 workspace 功能，需要工程根目录下存在 <code>pnpm-workspace.yaml</code> 配置文件，并且在 <code>pnpm-workspace.yaml</code> 中指定工作空间的目录。比如这里我们所有的子包都是放在 packages 目录下</p>\n<pre><code>packages:\n  - 'packages/*'\n</code></pre>\n<p>接下来，我们在 packages 文件夹下创建三个子项目，分别是：user-select、login 和 utils， 对应用户选择，登录 和工具类。</p>\n<pre><code>├── packages\n│   ├── user-select\n│   ├── login\n│   ├── utils\n</code></pre>\n<p>user-select 和 login 依赖 utils，我们可以将一些公用方法放到 utils 中。</p>\n<p>给每个 package 下面创建 <code>package.json</code> 文件，包名称通常是”@命名空间+包名@“的方式，比如@vite/xx 或@babel/xx，在本例中，这里我们都以<code>@mastack</code>开头</p>\n<pre><code>{\n  \"name\": \"@mastack/login\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n</code></pre>\n<p>给每个 package 安装 typescript</p>\n<pre><code>pnpm add typescript -r  -D\n</code></pre>\n<p>给每个 package 创建 tsconfig.json 文件</p>\n<pre><code>{\n  \"include\": [\"src/**/*\"],\n  \"compilerOptions\": {\n    \"jsx\": \"react\",\n    \"outDir\": \"dist\",\n    \"target\": \"ES2020\",\n    \"module\": \"esnext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"node\",\n    \"declaration\": true,\n    \"forceConsistentCasingInFileNames\": true\n  }\n}\n</code></pre>\n<p>执行下面代码，往 login 组件中安装 utils;</p>\n<pre><code>pnpm i @mastack/utils --filter @mastack/login\n</code></pre>\n<p>安装完成后，设置依赖版本的时候推荐用 <code>workspace:*</code>，就可以保持依赖的版本是工作空间里最新版本，不需要每次手动更新依赖版本。</p>\n<p>pnpm 提供了 <code>-w</code>, <code>--workspace-root</code> 参数，可以将依赖包安装到工程的根目录下，作为所有 package 的公共依赖，这么我们安装 <code>antd</code></p>\n<pre><code>pnpm install antd -w\n</code></pre>\n<h2>组件开发</h2>\n<p>我们在 login 组件下，新建一个组件 <code>src/index.tsx</code></p>\n<pre><code>import React, { useState } from 'react'\nimport { Button, Modal } from 'antd'\n\ninterface Props {\n  className: string;\n}\n\nexport default function Login({ className }: Props) {\n  const [open, setopen] = useState(false)\n  return (\n    &#x3C;>\n      &#x3C;Button onClick={() => setopen(true)} className={className}>\n        登录\n      &#x3C;/Button>\n      &#x3C;Modal title=\"登录\" open={open} onCancel={() => setopen(false)} onOk={() => setopen(false)}>\n        &#x3C;p>登录弹窗&#x3C;/p>\n      &#x3C;/Modal>\n    &#x3C;/>\n  )\n}\n</code></pre>\n<p>先写一个最简单版本，组件代码并不是最重要的，后续可以再优化。</p>\n<p>在 package.json 中添加构建命令</p>\n<pre><code>\"scripts\": {\n    \"build\": \"tsc\"\n  }\n</code></pre>\n<p>然后在组件目录下执行 <code>yarn build</code> 。此时组件以及可以打包成功！</p>\n<h2>Next.js 支持 MDX</h2>\n<p>接下来要让文档支持 MDX，在根目录下执行以下命令，安装 mdx 和 loader 相关包</p>\n<pre><code>pnpm add @next/mdx @mdx-js/loader @mdx-js/react -w\n</code></pre>\n<p>修改 <code>next.config.js</code> 为以下代码</p>\n<pre><code>const withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withMDX({\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\n  reactStrictMode: true,\n  swcMinify: true,\n})\n</code></pre>\n<p>这样就可以在 Next 中支持 MDX 了。</p>\n<p>我们在 <code>src/pages</code> 目录下，新建一个 <code>docs/index.mdx</code></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47e827c0dfbb4623875c4b9e16206471~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"markdown 信息\"></p>\n<p>先写一个简单的 markdown 文件测试下</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30f3a4c0bcad4fe782d1fe0b5594d873~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"markdown 渲染\"></p>\n<p>这样 Next.js 就支持 mdx 文档了。</p>\n<h2>Next 动态加载 md 文件</h2>\n<p>接下来，我们要实现动态加载 packages 中的文件 md 文件。新建一个 <code>pages/docs/[...slug].tsx</code> 文件。</p>\n<pre><code>export async function getStaticPaths(context: GetStaticPathsContext) {\n  return {\n    paths: [{ params: { slug: ['login'] } }, { params: { slug: ['user-selecter'] } }],\n    fallback: false, // SSG 模式\n  }\n}\n\nexport async function getStaticProps({ params }: GetStaticPropsContext&#x3C;{ slug: string[] }>) {\n  const slug = params?.slug.join('/')\n\n  return {\n    props: {\n      slug,\n    }, // 传递给组件的props\n  }\n}\n</code></pre>\n<p>我们使用的是 SSG 模式。上面代码中 <code>getStaticPaths</code> 我先写了 2 条数据，因为我们目前只有 2 个组件，它会在构建的时候会生成静态页面。 <code>getStaticProps</code>函数可以获取 URL 上的参数，我们将 slug 参数传递给组件，然后在 Page 函数中，我们使用 <code>next/dynamic</code> 动态加载 packages 中的 mdx 文件</p>\n<pre><code>import React from 'react'\nimport { GetStaticPathsContext, InferGetServerSidePropsType, GetStaticPropsContext } from 'next'\nimport dynamic from 'next/dynamic'\n\ntype Props = InferGetServerSidePropsType&#x3C;typeof getStaticProps>\n\nexport default function Page({ slug }: Props) {\n  const Content = dynamic(() => import(`../packages/${slug}/docs/index.mdx`), {\n    ssr: false,\n  })\n\n  return (\n    &#x3C;div>\n      &#x3C;Content />\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>此时我们访问 <code>http://localhost:3000/docs/login</code> 查看效果</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a084dc67f5f84f72b22af0c99e451d78~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Next.js 编译报错\"></p>\n<p>在页面上会提示，无法找到<code>@mastack/login</code> 这个包，我们需要在项目的根目录下的 <code>tsconfig.json</code> 中加入别名</p>\n<pre><code>{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"],\n      \"@mastack/login\": [\"packages/login/src\"],\n      \"@mastack/user-select\": [\"packages/user-select/src\"]\n    }\n  }\n}\n</code></pre>\n<p>保存后，页面会自动刷新，我们就可以在页面上看到如下效果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e97447d2968a46c89d1f63f1c9883d83~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Next.js  动态加载 mdx\"></p>\n<p>至此文档与 packages 目录下的 mdx 已经打通。修改 <code>packages/login/docs/index.mdx</code> 中的文档，页面会自动热更新。</p>\n<h2>自定义 mdx 组件</h2>\n<p>上面代码已经实现了在 md 文档中显示组件和代码，但我们想要的是类似于 ant design 那样的效果，默认代码不展示，点击可以收起和展开，这该怎么实现呢？</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57b68b7a21b9461b8ba0b5f2a449900b~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"ant design 代码块\"></p>\n<p>我们可以利用 mdx 的自定义组件来实现这个效果。</p>\n<p>写 mdx 的时候，在组件 <code>&#x3C;Login/></code>和代码外层嵌套一个自定义组件<code>DemoBlock</code></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21bc9aabd9644cfdada4b7dcbab8d052~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"markdown 信息\"></p>\n<p>然后实现一个自定义一个 <code>DemoBlock</code> 组件，提供给 <code>MDXProvider</code>，这样所有的 mdx 文档中，不需要 <code>import</code> 就可以使用组件。</p>\n<pre><code>import dynamic from 'next/dynamic'\nimport { MDXProvider } from '@mdx-js/react'\n\nconst DemoBlock = ({ children }: any) => {\n  console.log(children)\n  return null\n}\n\nconst components = {\n  DemoBlock,\n}\n\nexport default function Page({ slug }: Props) {\n  const Content = dynamic(() => import(`packages/${slug}/docs/index.mdx`), {\n    ssr: false,\n  })\n\n  return (\n    &#x3C;div>\n      &#x3C;MDXProvider components={components}>\n        &#x3C;Content />\n      &#x3C;/MDXProvider>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>我们先写一个空组件，看下 <code>children</code> 的值。刷新页面， 此时 <code>DemoBlock</code>中的组件和代码不会显示，我们看一下打印出的 <code>children</code> 节点信息；</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f470e8ba82d4936a698d1b5be87f9ce~tplv-k3u1fbpfcp-zoom-1.image\" alt=\" DemoBlock children 节点数据\"></p>\n<p>chilren 为 react 中的 vNode，现在我们就可以根据 type 来判断，返回不同的 jsx，这样就可以实现<code>DemoBlock</code>组件了，代码如下：</p>\n<pre><code>import React, { useState } from 'react'\n\nconst DemoBlock = ({ children }: any) => {\n  const [visible, setVisible] = useState(false)\n\n  return (\n    &#x3C;div className=\"demo-block\">\n      {children.map((child: any) => {\n        if (child.type === 'pre') {\n          return (\n            &#x3C;div key={child.key}>\n              &#x3C;div className=\"demo-block-button\" onClick={() => setVisible(!visible)}>\n                {!visible ? '显示代码' : '收起代码'}\n              &#x3C;/div>\n              {visible &#x26;&#x26; child}\n            &#x3C;/div>\n          )\n        }\n        return child\n      })}\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>再给组件添加一些样式，给按钮添加一个 svg icon，一起来看下实现效果：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6d414dd5ca94a93be1b07eb2f31d04c~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"组件文档 demo 效果\"></p>\n<p>是不是有跟 antd 的 demo block 有些相似了呢？ 若要显示更多字段和描述，我们可以修改组件代码，实现完全自定义。</p>\n<h2>优化文档界面</h2>\n<p>至此我们的文档，还是有些简陋，我们得优化下文档界面，让我们的界面显示更美观。</p>\n<ol>\n<li>安装并且初始化 tailwindcss</li>\n</ol>\n<pre><code>pnpm install -Dw tailwindcss postcss autoprefixer @tailwindcss/typography\npnpx tailwindcss init -p\n</code></pre>\n<p>修改 <code>globals.css</code> 为 tailwindcss 默认指令</p>\n<pre><code>@tailwind base;\n@tailwind components;\n@tailwind utilities;\n</code></pre>\n<p>修改 <code>tailwind.config.js</code> 配置文件，让我们的应用支持文章默认样式，并且在 md 和 mdx 文件中也可以写 tailwindcss</p>\n<pre><code>const defaultTheme = require('tailwindcss/defaultTheme')\nconst colors = require('tailwindcss/colors')\n\n/** @type {import(\"tailwindcss\").Config } */\nmodule.exports = {\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx,md,mdx}',\n    './components/**/*.{js,ts,jsx,tsx}',\n    './packages/**/*.{md,mdx}',\n  ],\n  darkMode: 'class',\n  plugins: [require('@tailwindcss/typography')],\n}\n</code></pre>\n<p>在 MDX Content 组件 外层可以加一个 <code>prose</code> class，这样我们的文档就有了默认好看文章样式了。</p>\n<p>现在 md 文档功能还很薄弱，我们需要让它强大起来，我们先安装一些 markdown 常用的包</p>\n<pre><code>pnpm install remark-gfm remark-footnotes remark-math rehype-katex rehype-slug rehype-autolink-headings rehype-prism-plus -w\n</code></pre>\n<ul>\n<li>\n<p><code>remark-gfm</code> 让 md 支持 GitHub Flavored Markdown （自动超链接链接文字、脚注、删除线、表格、任务列表）</p>\n</li>\n<li>\n<p><code>remark-math</code> <a href=\"url\">rehype-katex</a> 支持数学公式</p>\n</li>\n<li>\n<p><code>rehype-slug</code> <a href=\"url\">rehype-autolink-headings</a> 自动给标题加唯一 id</p>\n</li>\n<li>\n<p><code>rehype-prism-plus</code> 支持代码高亮</p>\n</li>\n</ul>\n<p>修改 <code>next.config.js</code> 为 <code>next.config.mjs</code>，并输入以下代码</p>\n<pre><code>// Remark packages\nimport remarkGfm from 'remark-gfm'\nimport remarkFootnotes from 'remark-footnotes'\nimport remarkMath from 'remark-math'\n// Rehype packages\nimport rehypeSlug from 'rehype-slug'\nimport rehypeAutolinkHeadings from 'rehype-autolink-headings'\nimport rehypePrismPlus from 'rehype-prism-plus'\n\nimport nextMDX from '@next/mdx'\n\nconst withMDX = nextMDX({\n  extension: /\\.mdx?$/,\n  options: {\n    remarkPlugins: [remarkMath, remarkGfm, [remarkFootnotes, { inlineNotes: true }]],\n    rehypePlugins: [rehypeSlug, rehypeAutolinkHeadings, [rehypePrismPlus, { ignoreMissing: true }]],\n  },\n})\n\nexport default withMDX({\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\n  reactStrictMode: true,\n  swcMinify: true,\n})\n</code></pre>\n<p>我们在这里可以配置 remarkPlugins 和 rehypePlugins；</p>\n<p>markdown 在编译过程中会涉及 3 种 ast 抽象语法树 ， remark 负责转换为 mdast，它可以操作 markdown 文件，比如让 markdown 支持更多格式（比如：公式、脚注、任务列表等），需要使用 remark 插件； rehype 负责转换为 hast ，它可以转换 html，比如给 标题加 id，给代码高亮， 这一步是在操作 HTML 后完成的。因此我们也可以自己写插件，具体写什么插件，就要看插件在哪个阶段运行。</p>\n<p>最后我们到 github <a href=\"https://github.com/PrismJS/prism-themes/blob/master/themes/prism-atom-dark.css\">prism-themes</a> 中复制一份代码高亮的样式到我们的 css 文件中，一起来看下效果吧！</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958db388c7dc45728c2a8b16fd74d3a9~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"组件文档代码高亮\"></p>\n<h2>发布工作流</h2>\n<p>workspace 中的包版本管理是一个复杂的任务，pnpm 目前也并未提供内置的解决方案。pnpm 推荐了两个开源的版本控制工具：changesets 和 rush，这里我采用了 <a href=\"https://github.com/changesets/changesets\" title=\"changesets\">changesets</a> 来实现依赖包的管理。</p>\n<h3>配置</h3>\n<p>要在 pnpm 工作空间上配置 changesets，请将 changesets 作为开发依赖项安装在工作空间的根目录中：</p>\n<pre><code>pnpm add -Dw @changesets/cli\n</code></pre>\n<p>然后 changesets 的初始化命令：</p>\n<pre><code>pnpm changeset init\n</code></pre>\n<h3>添加新的 changesets</h3>\n<p>要生成新的 changesets，请在仓库的根目录中执行<code>pnpm changeset</code>。 <code>.changeset</code> 目录中生成的 markdown 文件需要被提交到到仓库。</p>\n<h3>发布变更</h3>\n<p>为了方便所有包的发布过程，在工程根目录下的 pacakge.json 的 scripts 中增加如下几条脚本：</p>\n<pre><code>\"compile\": \"pnpm --filter=@mastack/* run build\",\n\"pub\": \"pnpm compile &#x26;&#x26; pnpm --recursive --registry https://registry.npmjs.org/ publish --access public\"\n</code></pre>\n<p>编译阶段，生成构建产物</p>\n<ol>\n<li>运行<code>pnpm changeset version</code>。 这将提高先前使用 <code>pnpm changeset</code> （以及它们的任何依赖项）的版本，并更新变更日志文件。</li>\n<li>运行 <code>pnpm install</code>。 这将更新锁文件并重新构建包。</li>\n<li>提交更改。</li>\n<li>运行 <code>pnpm pub</code>。 此命令将发布所有包含被更新版本且尚未出现在包注册源中的包。</li>\n</ol>\n<h2>部署</h2>\n<p>部署可以选择 gitbub pages 或者 vercel 部署，他们都是免费的，Github pages 只支持静态网站，vercel 支持动态网站，它会将 nextjs page 中，单独部署成函数的形式。我这里选择使用 vercel，因为它的访问速度相对比 gitbub pages 要快很多。只需要使用 github 账号登录 https://vercel.com/ 导入项目，便会自动部署，而且会自动分配一个 https://xxx.vercel.app/ 二级域名。</p>\n<p>也可以使用命令行工具，在项目跟目录下执行，根据提示，选择默认即可</p>\n<pre><code>npx vercel\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db59465d9a384b158955a2ed1e69b25d~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"vercel 部署\"></p>\n<p>预览地址：https://nextjs-components-docs.vercel.app/</p>\n<h2>小结</h2>\n<p>本文，我们从零开始，使用 Next.js 和 pnpm 搭建了一个组件库文档，主要使用 Next.js 动态导入功能解决了开发服务缓慢的问题，使用 Next.js 的 SSG 模式来生成静态文档。最后我们使用 changesets 来管理包的 version 和生成 changelog。</p>\n<p>好了，以上就是本文的全部内容，你学会了吗？接下来我将继续分享 Next.js 相关的实战文章，欢迎各位关注我的《 Next.js 全栈开发实战》 专栏，感谢您的阅读。</p>\n"}}],["$","div",null,{"className":"items-center","children":["$","$L5",null,{"href":"articles","children":"返回文档列表"}]}]]}]}]
