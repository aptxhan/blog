1:HL["/_next/static/css/26351ac1a6eca06c.css",{"as":"style"}]
0:[[["",{"children":["articles",{"children":[["slug","hooks","d"],{"children":["__PAGE__?{\"slug\":\"hooks\"}",{}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/26351ac1a6eca06c.css","precedence":"next"}]],["$L3",null]]]]
4:HL["/_next/static/css/7f6bd37aab40623f.css",{"as":"style"}]
5:I{"id":"414","chunks":["414:static/chunks/414-4c4d64a76277ff85.js","345:static/chunks/app/articles/page/[slug]/page-b019257bdb7591a1.js"],"name":"","async":false}
6:I{"id":"9544","chunks":["272:static/chunks/webpack-afd6b160f7b2e7a5.js","667:static/chunks/2443530c-da705fa45a107f29.js","139:static/chunks/139-a98e23425a4dfbf4.js"],"name":"","async":false}
7:I{"id":"99","chunks":["272:static/chunks/webpack-afd6b160f7b2e7a5.js","667:static/chunks/2443530c-da705fa45a107f29.js","139:static/chunks/139-a98e23425a4dfbf4.js"],"name":"","async":false}
8:I{"id":"1389","chunks":["120:static/chunks/120-384f50ccf38e1ade.js","70:static/chunks/app/articles/layout-8324812b78a65603.js"],"name":"","async":false}
2:[["$","html",null,{"lang":"zh-CN","className":"scroll-smooth dark","children":[["$","meta",null,{"charSet":"utf-8"}],["$","body",null,{"children":[["$","div",null,{"className":"mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0","children":["$","div",null,{"className":"h-screen flex flex-col justify-between","children":[["$","header",null,{"className":"flex items-center justify-around py-10","children":[["$","div",null,{"children":["$","$L5",null,{"href":"/","children":["$","div",null,{"className":"flex items-center justify-between","children":["$","div",null,{"className":"hidden h-6 text-2xl font-semibold sm:block","children":["$","a",null,{"children":"HAN个人博客"}]}]}]}]}],["$","div",null,{"className":"flex items-center text-base leading-5","children":["$","div",null,{"className":"hidden sm:block","children":[["$","$L5","/",{"href":"/","className":"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4","children":"主页"}],["$","$L5","/articles",{"href":"/articles","className":"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4","children":"文章"}],["$","$L5","/about",{"href":"/about","className":"p-1 font-medium text-gray-900 dark:text-gray-100 sm:p-4","children":"关于"}]]}]}],["$","div",null,{}]]}],["$","main",null,{"className":"mb-auto","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":["$","div",null,{"className":"flex flex-col items-start justify-start md:mt-24 md:flex-row md:items-center md:justify-center md:space-x-6","children":[["$","div",null,{"className":"space-x-2 pt-6 pb-8 md:space-y-5","children":["$","h1",null,{"className":"text-6xl font-extrabold leading-9 tracking-tight text-gray-900 dark:text-gray-100 md:border-r-2 md:px-6 md:text-8xl md:leading-14","children":"404"}]}],["$","div",null,{"className":"max-w-md","children":[["$","p",null,{"className":"mb-4 text-xl font-bold leading-normal md:text-2xl","children":"抱歉，这个页面暂时没找到"}],["$","p",null,{"className":"mb-8","children":"别急，您可以可以返回首页找找！"}],["$","$L5",null,{"href":"/","children":["$","button",null,{"className":"focus:shadow-outline-blue inline rounded-lg border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium leading-5 text-white shadow transition-colors duration-150 hover:bg-blue-700 focus:outline-none dark:hover:bg-blue-500","children":"返回主页"}]}]]}]]}],"notFoundStyles":[],"asNotFound":"$undefined","childProp":{"current":[["$","$L8",null,{"children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children",["slug","hooks","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","asNotFound":"$undefined","childProp":{"current":["$L9",null],"segment":"__PAGE__?{\"slug\":\"hooks\"}"},"styles":[]}],"segment":["slug","hooks","d"]},"styles":[]}],"params":{}}],null],"segment":"articles"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/7f6bd37aab40623f.css","precedence":"next"}]]}]}],["$","footer",null,{"children":["$","div",null,{"className":"mt-16 flex flex-col items-center","children":["$","div",null,{"className":"mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400","children":[["$","div",null,{"children":"© 2023"}],["$","div",null,{"children":" • "}],["$","$L5",null,{"href":"/","children":"HAN|博客"}]]}]}]}]]}]}],["$","div",null,{}]]}]]}],null]
3:[[["$","meta",null,{"charSet":"utf-8"}],["$","title",null,{"children":"HAN Blog"}],["$","meta",null,{"name":"description","content":"Created by HAN"}],null,null,null,null,null,null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[["$","link",null,{"rel":"icon","href":"\\favicon.ico","type":"image/x-icon","sizes":"any"}]],[],null]]
9:["$","div",null,{"className":"flex justify-center","children":["$","div",null,{"className":"prose dark:prose-invert mt-10","children":[["$","h1",null,{"children":"如何避免 React hooks 闭包陷阱？"}],["$","div",null,{"className":"items-center","children":["$","$L5",null,{"href":"articles","children":"返回文档列表"}]}],["$","div",null,{"dangerouslySetInnerHTML":{"__html":"<h2>什么是 React hooks 闭包陷阱？</h2>\n<p>在 react 中 提供了一些性能优化函数 <code>react.memo</code> 、<code>useMemo</code>、<code>useCallback</code>。</p>\n<pre><code>const cachedValue = useMemo((fn) => calculateValue, dependencies)\n</code></pre>\n<p><strong>useMemo</strong>：memoized 值，只有依赖项变更的时候才会重新计算</p>\n<pre><code>const cachedFn = useCallback(fn, dependencies)\n</code></pre>\n<p><strong>useCallback</strong>：memoized 函数，只有依赖项变更的时候才会重新更新</p>\n<pre><code>const MemoizedComponent = memo(SomeComponent, arePropsEqual?)\n</code></pre>\n<p><strong>memo</strong>：缓存组件，当 props 没变化的时候，不会执行 render。<code>arePropsEqual</code> 是一个可选函数，可以自定义对比新旧的 <code>props</code>, 返回 <code>true</code> 就会缓存，返回 <code>false</code>，就不会缓存。</p>\n<pre><code>const arePropsEqual=(oldProps: Props, newProps: Props) => boolean\n</code></pre>\n<p>有时候我们使用了这些函数来优化性能，这些函数与外围的 state 形成闭包，导致缓存函数中获取到的 state 不是最新的值，这就是闭包陷阱。</p>\n<h2>实例演示</h2>\n<p>比如下面代码，在项目中有一个计时器组件，还有一个 <code>Child</code> 组件, 点击 <code>Child</code> 组件需要返回 App 组件中的最新 <code>state</code> 值；</p>\n<pre><code>import React, { useCallback, useEffect, useLayoutEffect } from 'react'\nimport 'antd/dist/antd.css'\nimport { Button, ButtonProps } from 'antd'\n\nconst Child = ({ onClick }: ButtonProps) => {\n  console.log('render')\n  return (\n    &#x3C;Button onClick={onClick} type=\"primary\">\n      Button\n    &#x3C;/Button>\n  )\n}\n\nconst App: React.FC = () => {\n  const [count, setCount] = React.useState(0)\n\n  useEffect(() => {\n    const time = setInterval(() => {\n      setCount((count) => count + 1)\n    }, 1000)\n    return () => {\n      clearInterval(time)\n    }\n  }, [])\n\n  const handleClick = () => {\n    console.log(count)\n  }\n\n  return (\n    &#x3C;>\n      &#x3C;h2>{count}&#x3C;/h2>\n      &#x3C;Child onClick={handleClick} />\n    &#x3C;/>\n  )\n}\n\nexport default App\n</code></pre>\n<p>这样没什么问题，但是每次渲染的时候 <code>Child</code> 组件都会执行 render</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ffc82d64fd84254b2a988cb0f340bdd~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>为了防止 App 组件在更新的时候，不重复渲染（render）子组件，我们使用 <code>React.memo</code> 包裹下 <code>Child</code> 组件， <code>handleClick</code> 也需要使用 <code>useCallback</code> 包裹，这样 <code>Child</code> 组件只会 render 一次。</p>\n<pre><code>const Child = React.memo(({ onClick }: ButtonProps) => {\n  console.log('render')\n  return (\n    &#x3C;Button onClick={onClick} type=\"primary\">\n      Button\n    &#x3C;/Button>\n  )\n})\n</code></pre>\n<pre><code>const handleClick = useCallback(() => {\n    console.log(count);\n  }, []);\n</code></pre>\n<p>这样一来 <code>useCallback</code> 和 state 就形成了一个闭包，每次打印的 state 就是初始化的 state。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18a20ad358d44a29ef944ca483489da~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p>为了获得最新的 state 值，必须将 count 参数写进 useCallback 的第二个参数。</p>\n<pre><code>const handleClick = useCallback(() => {\n  console.log(count)\n}, [count])\n</code></pre>\n<p>但这样，又会导致 <code>Child</code> 组件更新。那么有什么好的解决办法呢？既能防止子组件的更新，又可以获取到最新的 <code>state</code> 值呢？</p>\n<p><strong>方法：</strong></p>\n<p>我们可以使用 <code>useRef</code> 来存一个函数，每次更新的时候设置 <code>ref.current</code> 的值，通过函数来获取最新的 <code>state</code> 值。</p>\n<pre><code>const App: React.FC = () => {\n  const [count, setCount] = React.useState(0);\n  const ref = React.useRef&#x3C;VoidFunction>();\n\n  useEffect(() => {\n    const time = setInterval(() => {\n      setCount((count) => count + 1);\n    }, 1000);\n    return () => {\n      clearInterval(time);\n    };\n  }, []);\n\n  const fn = () => {\n    console.log(count);\n  };\n\n  ref.current = fn;\n\n  const handleClick = useCallback(() => {\n    ref.current();\n  }, []);\n\n  return (\n    &#x3C;>\n      &#x3C;h2>{count}&#x3C;/h2>\n      &#x3C;Child onClick={handleClick} />\n    &#x3C;/>\n  );\n};\n\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36531d7c4f1f4c6d987991568df7a2dc~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"></p>\n<p><a href=\"https://codesandbox.io/s/an-niu-lei-xing-antd-4-24-2-forked-wv1w0q?file=/demo.tsx\">codesandbox 演示地址</a></p>\n<h2>小结</h2>\n<p>解决闭包陷阱的方法</p>\n<ol>\n<li>\n<p>当页面更新不频繁的时候，不使用 <code>useMemo</code>、<code>useCallback</code> 缓存函数来优化页面；</p>\n</li>\n<li>\n<p>将更新依赖的参数写进 <code>useCallback</code> 的第二个参数</p>\n</li>\n<li>\n<p>使用 <code>useRef</code> 来存在一个函数，用一个函数实时获取最新的 <code>state</code> 值</p>\n</li>\n</ol>\n<p>以上就是本文全部内容，如果对你有帮助，可以随手点个赞，这对我真的很重要，希望这篇文章对大家有所帮助，也可以参考我往期的文章或者在评论区交流你的想法和心得，欢迎一起探索前端。</p>\n<blockquote>\n<p>本文正在参加<a href=\"https://juejin.cn/post/7162096952883019783\" title=\"https://juejin.cn/post/7162096952883019783\">「金石计划 . 瓜分 6 万现金大奖」</a></p>\n</blockquote>\n"}}],["$","div",null,{"className":"items-center","children":["$","$L5",null,{"href":"articles","children":"返回文档列表"}]}]]}]}]
